#scope_export

MEMLEAK_CHECK :: 0;

/*
An object that can be serialized to a bitstream.

Messages are objects that are sent between client and server across the connection. They are carried inside the
ConnectionPacket generated by the Connection class. Messages can be sent reliable-ordered, or unreliable-unordered,
depending on the configuration of the channel they are sent over.

To use messages, create your own set of message structs by "inheriting" from this struct:

    MyMessage :: struct {
        #as base: Message;
        some_field: int;
    }

@see Connection
*/
Message :: struct {
    id        : u16;    // The message id. For messages sent over reliable-ordered channels, this starts at 0 and increases with each message sent. For unreliable-unordered channels this is set to the sequence number of the packet the message was included in.
    type      : u16;    // The message type. Corresponds to the type integer used when the message was created though the message factory.
    blockData : [] u8;  // The block data. Empty if no block is attached.
    refCount  : int;
}

message_acquire :: (message: *Message) -> *Message {
    message.refCount += 1;

    #if MEMLEAK_CHECK {
        log("\nAcquired message % id % type %, refCount = %\n", message, message.id, message.type, message.refCount);
        log_stack_trace(context.stack_trace, .VERBOSE_ONLY);
        log("\n");
    }

    return message;
}

message_release :: (message: *Message) {
    assert_greater(message.refCount, 0);
    if message.refCount > 0 {
        message.refCount -= 1;
    }

    #if MEMLEAK_CHECK {
        log("\nReleased message % id % type %, refCount = %\n", message, message.id, message.type, message.refCount);
        log_stack_trace(context.stack_trace, .VERBOSE_ONLY);
        log("\n");
    }

    if message.refCount == 0 {
        if message.blockData.count > 0 {
            array_free(message.blockData);
        }
        free(message);
    }
}

/*
A MessageFactory defines the set of message types that can be created.

User code should define an enum of all message types:

    MessageType :: enum {
        Connect;
        Login;
        InputCommand;
    }

And define a serialize function (or one per message type) that can handle the serialization logic:

    serialize :: (stream: *$S, message: *Message) -> bool {
        if #complete cast(MessageType) message.type == {
            case .Connect;
                msg := cast(*MsgConnect) message;
                serialize_int(stream, msg.foo);
            case .Login;
                msg := cast(*MsgLogin) message;
                serialize_string(stream, msg.username);
                serialize_string(stream, msg.password);
            case .InputCommand;
                msg := cast(*MsgInputCommand) message;
                serialize_int(stream, msg.primaryAction);
                serialize_int(stream, msg.secondaryAction);
        }
        return false;
    }

As well as a router for the various kinds of streams:

    // TODO(dlb): Make a macro that makes this part suck less for the user.
    serialize_router :: (msgFactory: *MessageFactory, stream: *Stream, message: *Message) -> bool {
        m := cast(*msgFactory.messages[message.id]) message;
        if #complete stream.type == {
            case .Write;   return serialize(cast(*WriteStream  ) stream, m);
            case .Read;    return serialize(cast(*ReadStream   ) stream, m);
            case .Measure; return serialize(cast(*MeasureStream) stream, m);
        }
    }

Then register those messages types and the router with the MessageFactory:

    msgFactory: MessageFactory;
    msgFactory.messages = .[MsgConnect, MsgLogin, MsgInputCommand];
    msgFactory.serializeRouter = serialize_router;

*/
MessageSerializer :: struct {
    create    : () -> *Message;
    serialize : (stream: *Stream, message: *Message) -> bool;
}

// IMPORTANT: The index of the type in the this array must be the message ID (i.e. it should match your enum).
MessageFactory :: #type,isa [] MessageSerializer;

message_factory_create_message :: (messageFactory: MessageFactory, messageType: u16) -> *Message {
    msg := messageFactory[messageType].create();
    msg.type = messageType;
    return msg;
}

#scope_module

/*
Helper function to serialize a block attached to a message. Used by channel implementations.
 */
serialize_message_block :: (stream: *Stream, message: *Message, maxBlockSize: int) -> bool {
    isBlockMessage := stream.isWriting && message.blockData.count > 0;
    serialize_bool(stream, *isBlockMessage);
    if !isBlockMessage {
        return true;
    }

    blockSize: int = ifx stream.isWriting then cast(int) message.blockData.count else 0;
    serialize_int(stream, *blockSize, 1, maxBlockSize);

    if stream.isReading {
        message.blockData = NewArray(blockSize, u8);
    }
    serialize_bytes(stream, message.blockData);

    return true;
}

#scope_file

#import "Serialize";